# WebAssembly (Wasm)

WebAssembly was aimed primarily at the web platform.
Think of WebAssembly like a tiny simulated computer: it has it's own call stack and instructions, it's own byte-array of memory, and is sandboxed unless access to the outside world is explicitely provided.
It is good at calculating and things, and calling functions from the outside if provided.

It was originally built for web browsers as a way to run code other than JavaScript (JS) in the browser.
Web apps that use both JavaScript and WebAssembly modules was the general expected outcome.
The particularly use case in mind was that computationally intensive code that JS is not good at dealing with could be done in WebAssembly instead.
For example, Photoshop-in-the browser took C++ code from the desktop app and compiled it to wasm to make a fully featured web version that can do a lot of the processing locally without having to go to the server and incure latency.

Being able to run code in the browser at near native speeds can also improve the iteration time of the web platform though.
For example, you no longer have to wait for universal JPEG 2000 support in all browsers.
Instead, a decoder can be cross-compiled from a high-level language to to WebAssembly and called from JavaScript.
Browsers could therefore focus on exposing low-level hardware primitives (WebGL, Bluetooth, USB, etc.) and leave the development of higher-level libraries to the community.

The wasm programming language has two formats, a human-readable `.wat` text format that is useful for debugging purposes, and a `.wasm` format intended for consumption by the wasm VM.
Wasm code is a low level-of abstraction intended to be generated by compilers rather than being written by humans.
The wasm executable format was designed to be portable and compact.
The wasm binary file can be used in the same process as another language.
In JS the wasm binary gets compiled into a module and called from JS runtime context.

The WebAssembly System interface (WASI) standard is like an API ontop of WebASsembly. The (preview1) spec API provides for:

- command line arguments
- environment variables
- clock time
- get random
- file system access
- _use_ sockets (but not create them)

A note on Assembly versus WebAssembly because they can be confused. While both assembly language and WebAssembly are low-level programming languages, assembly language is specific to particular hardware architectures and is used for low-level system programming, whereas WebAssembly is a platform-independent bytecode format designed for running code efficiently in web browsers.

## Tooling

`wasm-pack` is your one-stop shop for building, testing, and publishing Rust-generated WebAssembly.
`cargo-generate` helps you get up and running quickly with a new Rust project by leveraging a pre-existing git repository as a template.
