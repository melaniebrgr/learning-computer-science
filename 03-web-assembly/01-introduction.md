# WebAssembly (Wasm)

## A binary instruction format for a stack-based virtual machine.

WebAssembly bytecode is encoded for a stack based virtual machine.
A virtual machine is something that executes a specific set of possible instructions on specific data in a specific region of computer memory.
A stack machine is a way of representing computation.
The memory structural paradigm in the case of WebAssembly, is a stack, and a stack is a block of memory onto which data can only be pushed or popped, by convention.
For a stack based machine, example instructions are PUSH, ADD, and PRINT.
We could come up with _any_ naive binary format to capture those allowed instructions, WebAssembly is just one of them that is well thought out now.
If you can compile your code to this particular "wasm" binary format, then you can run the code wherever the wasm VM is supported, which is no _a lot of places_ including _all major browsers_.

## Available in your browser

WebAssembly was aimed primarily at the web platform.
Think of WebAssembly like a tiny simulated computer: it has it's own call stack and instructions, it's own byte-array of memory, and is sandboxed unless access to the outside world is explicitely provided.
It is good at calculating and things, and calling functions from the outside if provided.

It was originally built for web browsers as a way to run code other than JavaScript (JS) in the browser.
Web apps that use both JavaScript and WebAssembly modules was the general expected outcome.
The particularly use case in mind was that computationally intensive code that JS is not good at dealing with could be done in WebAssembly instead.
For example, Photoshop-in-the browser took C++ code from the desktop app and compiled it to wasm to make a fully featured web version that can do a lot of the processing locally without having to go to the server and incure latency.

Being able to run code in the browser at near native speeds can also improve the iteration time of the web platform though.
For example, you no longer have to wait for universal JPEG 2000 support in all browsers.
Instead, a decoder can be cross-compiled from a high-level language to to WebAssembly and called from JavaScript.
Browsers could therefore focus on exposing low-level hardware primitives (WebGL, Bluetooth, USB, etc.) and leave the development of higher-level libraries to the community.

Wasm is generally available now wherever you can execute JavaScript: Chrome, FireFox, Safari, Egde, Node.js, and Deno.
For non-web based usage, the following wasm runtimes are available: Wasmtime, Wasmer, Wasm3, WasmEdge, WebAssembly Micro Runtime, Wazero.
According to the [State of WebAssembly 2023 survey](https://blog.scottlogic.com/2023/10/18/the-state-of-webassembly-2023.html), "WebAssembly is still most often used for web application development, but serverless is continuing to rise, as is the use of WebAssembly as a plugin environment".

## WebAssembly Text

In the beginning, programmers would code in the numbers of particular native code instructions listed in the OSs hardware manual.
Later, to make things more convenient, human readable numonics were assigned to these numerical instructions.
This was Assembly.

WebAssembly is a binary format, the human readable format is WebAssembly Text or WAT.
The wasm programming language has two formats, a human-readable `.wat` text format that is useful for debugging purposes, and a `.wasm` format intended for consumption by the wasm VM.
Wasm code is a low level-of abstraction intended to be generated by compilers rather than being written by humans.
The wasm executable format was designed to be portable and compact.
The wasm binary file can be used in the same process as another language.
In JS the wasm binary gets compiled into a module and called from JS runtime context.

The WebAssembly System interface (WASI) standard is like an API ontop of WebASsembly. The (preview1) spec API provides for:

- command line arguments
- environment variables
- clock time
- get random
- file system access
- _use_ sockets (but not create them)

A note on Assembly versus WebAssembly because they can be confused. While both assembly language and WebAssembly are low-level programming languages, assembly language is specific to particular hardware architectures and is used for low-level system programming, whereas WebAssembly is a platform-independent bytecode format designed for running code efficiently in web browsers.

## Webassembly System Interface (WASI)

Wasm by itself can't really do much, essentially just calculations.
A way to provide functionality to WebAssembly that it doesn't already have is with WASI.
Each outside function must be explicitely passed in.
WASI is an effort to standardise what functionality can be passed in.
WASI is POSIX for WebAssembly

## Tooling

`wasm-pack` is your one-stop shop for building, testing, and publishing Rust-generated WebAssembly.
`cargo-generate` helps you get up and running quickly with a new Rust project by leveraging a pre-existing git repository as a template.
